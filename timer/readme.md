基于第2段工作偷师的一个定时器模块思想

基本原理：用一个有序列表（类似redis的zset）记录在指定的时间戳到点时应该触发的所有触发器函数
上传的这一段代码用的是一个map，key是秒级时间戳，一个简化的模板，在当时工作的工程里用的有序map（功能相当于map，但key在底层有序排列的数据结构，类似于C++里的std::map，但go基本数据结构没有这个（原因：go的map底层是无序的哈希），得手撕） ，key是毫秒级时间戳。
然后用一个time.Ticker打点（当时打点频率也是毫秒级，这里的代码用了秒级）跑select case，
从ticker.C里每消化1个Time数据，在map里提取所有小于这个Time的时间戳的触发器并根据预设参数触发（这就是为什么要用有序map，无序map每次都要全遍历效率很低）
然后轮下一个ticker循环执行

可以在main里单跑一个timer.TimerTestCode()看效果