基于第2段工作偷师的一个定时器模块思想

基本原理：用一个有序列表（类似redis的zset）记录在指定的时间戳到点时应该触发的所有触发器函数
上传的这一段代码用的是一个map，key是秒级时间戳，一个简化的模板，在当时工作的工程里用的有序map（功能相当于map，但key在底层有序排列的数据结构，类似于C++里的std::map，但go基本数据结构没有这个（原因：go的map底层是无序的哈希），得手撕） ，key是毫秒级时间戳。
然后用一个time.Ticker打点（当时打点频率也是毫秒级，这里的代码用了秒级）跑select case，
从ticker.C里每消化1个Time数据，在map里提取所有小于这个Time的时间戳的触发器并根据预设参数触发（这就是为什么要用有序map，无序map每次都要全遍历效率很低）
然后轮下一个ticker循环执行

可以在main里单跑一个timer.TimerTestCode()看效果

这种计时器的缺点：如果同一时刻（或者相邻时刻）排着的触发器太多，那么由于必须全部都要执行，因此循环遍历不可避免，需要一个O(n)的过程
而且触发器事件本身的时间复杂度也没法保证，因此一次ticker可能会占用大量时间处理触发器，导致一些本来注册到特定时间点的触发器被延后了很久才触发，是那种人脑都能感受得到的延后程度
曾经QA报过一个bug是凌晨12点准点触发的事件，报12点零40秒才触发，自测后发现也确实如此，并且每次自测触发的延后时间还不一致，有的20几秒，有的30几秒，最短也要10几秒，相同的是没有过一次准点
debug模式排查填入的触发时间戳完全没有问题就是12点正点的时间戳
后来日志发现那个点还有一项需要大规模刷新大地图的事件，这个事件安排在了完全相同的12点时间戳里，然后注册事件时它排靠前，就让它占用了很长时间

因此这个计时器可能也不是完美方案，而且在注册计时器的时候，要尽量避免同一时刻堆积太多东西。
但截止到离开，这个计时器代码并没有过任何技术性调整（最多引入了一些模板化思想

ps：前项目的偶现bug里90%跟计时器有关，要hold住计时器功能不容易啊